// Code generated by genfig plugin 'update_from_env'; DO NOT EDIT.

package config

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
)

var (
	_ = os.LookupEnv
	_ = fmt.Sprintf
	_ = json.Marshal
)

func (c *Config) UpdateFromEnv() []error {
	var val string
	_ = val
	var exists bool
	_ = exists
	var envs []string
	_ = envs
	var errors = []error{}

	envs = []string{"apis.google.uri", "APIS_GOOGLE_URI"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Apis.Google.Uri = val
	}

	envs = []string{"db.pass", "DB_PASS"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Db.Pass = val
	}

	envs = []string{"db.uri", "DB_URI"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Db.Uri = val
	}

	envs = []string{"db.user", "DB_USER"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Db.User = val
	}

	envs = []string{"emptyarray", "EMPTYARRAY"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseInterfaceSlice(val, &c.EmptyArray); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse []interface {} from CONFIG_EMPTYARRAY ('%s')\n", val))
		}
	}

	envs = []string{"list", "LIST"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseMapSlice(val, &c.List); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse []map[string]interface {} from CONFIG_LIST ('%s')\n", val))
		}
	}

	envs = []string{"longdesc.de", "LONGDESC_DE"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.LongDesc.De = val
	}

	envs = []string{"longdesc.en", "LONGDESC_EN"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.LongDesc.En = val
	}

	envs = []string{"project", "PROJECT"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Project = val
	}

	envs = []string{"randomizer.threshold", "RANDOMIZER_THRESHOLD"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseFloat64(val, &c.Randomizer.Threshold); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse float64 from CONFIG_RANDOMIZER_THRESHOLD ('%s')\n", val))
		}
	}

	envs = []string{"secrets", "SECRETS"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseStringSlice(val, &c.Secrets); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse []string from CONFIG_SECRETS ('%s')\n", val))
		}
	}

	envs = []string{"server.host", "SERVER_HOST"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Server.Host = val
	}

	envs = []string{"server.port", "SERVER_PORT"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseInt64(val, &c.Server.Port); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse int64 from CONFIG_SERVER_PORT ('%s')\n", val))
		}
	}

	envs = []string{"version", "VERSION"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		c.Version = val
	}

	envs = []string{"wip", "WIP"}
	for _, env := range envs {
		if val, exists = os.LookupEnv(env); exists {
			break
		}
	}
	if exists {
		if err := parseBool(val, &c.Wip); err != nil {
			errors = append(errors, fmt.Errorf("Genfig: could not parse bool from CONFIG_WIP ('%s')\n", val))
		}
	}

	if len(errors) == 0 {
		return nil
	} else {
		return errors
	}
}

// these are wrappers, so that they can
// a) be referenced easily be the code generator and
// b) be replaces easily by you (or me)
func parseInt64(s string, i *int64) (err error) {
	if got, err := strconv.ParseInt(s, 10, 0); err == nil {
		*i = got
	}
	return
}

func parseFloat64(s string, f *float64) (err error) {
	if got, err := strconv.ParseFloat(s, 0); err == nil {
		*f = got
	}
	return
}

func parseBool(s string, b *bool) (err error) {
	if got, err := strconv.ParseBool(s); err == nil {
		*b = got
	}
	return
}

func parseStringSlice(s string, a *[]string) (err error) {
	add := false
	if strings.HasPrefix(s, "+") {
		add = true
		s = s[1:]
	}
	tmp := []string{}
	if err = json.Unmarshal([]byte(s), &tmp); err != nil {
		return
	}
	if add {
		*a = append(*a, tmp...)
	} else {
		*a = tmp
	}
	return
}

func parseInt64Slice(s string, a *[]int64) (err error) {
	add := false
	if strings.HasPrefix(s, "+") {
		add = true
		s = s[1:]
	}
	tmp := []int64{}
	if err = json.Unmarshal([]byte(s), &tmp); err != nil {
		return
	}
	if add {
		*a = append(*a, tmp...)
	} else {
		*a = tmp
	}
	return
}

func parseFloat64Slice(s string, a *[]float64) (err error) {
	add := false
	if strings.HasPrefix(s, "+") {
		add = true
		s = s[1:]
	}
	tmp := []float64{}
	if err = json.Unmarshal([]byte(s), &tmp); err != nil {
		return
	}
	if add {
		*a = append(*a, tmp...)
	} else {
		*a = tmp
	}
	return
}

func parseInterfaceSlice(s string, a *[]interface{}) (err error) {
	add := false
	if strings.HasPrefix(s, "+") {
		add = true
		s = s[1:]
	}
	tmp := []interface{}{}
	if err = json.Unmarshal([]byte(s), &tmp); err != nil {
		return
	}
	if add {
		*a = append(*a, tmp...)
	} else {
		*a = tmp
	}
	return
}

func parseMapSlice(s string, a *[]map[string]interface{}) (err error) {
	add := false
	if strings.HasPrefix(s, "+") {
		add = true
		s = s[1:]
	}
	tmp := []map[string]interface{}{}
	if err = json.Unmarshal([]byte(s), &tmp); err != nil {
		return
	}
	if add {
		*a = append(*a, tmp...)
	} else {
		*a = tmp
	}
	return
}
